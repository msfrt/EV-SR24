/*****************************************************************************
   Table_Functions.c
   Generated By:
   Raptor 2023a_2.0.15039 (7682)
   Matlab (R2022b) 9.13

   Copyright (c) 2023 New Eagle Products, Inc.
   All rights reserved.

   Code Generated at: Tue Oct 17 21:06:40 2023
 *****************************************************************************/

#include "EVSR24.h"

typedef struct {
  uint32_T hi;
  uint32_T lo;
} bigInt_T;

void uint32_TTobigInt(uint32_T in, bigInt_T *out)
{
  out->hi = 0;
  out->lo = in;
}

void int32_TTobigInt(int32_T in, bigInt_T *out)
{
  if (in >= 0) {
    out->hi = 0;
    out->lo = (uint32_T) in;
  } else {
    out->hi = 0x80000000;
    out->lo = (uint32_T) -in;
  }
}

uint32_T bigIntTouint32_T(bigInt_T *in)
{
  return in->lo;
}

int32_T bigIntToint32_T(bigInt_T *in)
{
  int32_T temp = (int32_T)(in->lo & 0x7FFFFFFF);
  if (in->hi & 0x80000000)
    return -temp;
  else
    return temp;
}

boolean_T absGreaterThan(bigInt_T* op1, bigInt_T* op2)
{
  if ((op1->hi & 0x7FFFFFFF) == (op2->hi & 0x7FFFFFFF))
    return op1->lo > op2->lo;
  else
    return (op1->hi & 0x7FFFFFFF) > (op2->hi & 0x7FFFFFFF);
}

void multBigInt(bigInt_T *op1, uint16_T op2, bigInt_T *retValue)
{
  uint32_T temp;
  bigInt_T ret;                        //buffer incase input == output

  //multiply lower part
  ret.lo = (op1->lo & 0xFFFF) * op2;
  temp = ((op1->lo & 0xFFFF0000)>>16)*op2;
  ret.lo += (temp & 0xFFFF)<<16;

  //multiply upper part
  ret.hi = (op1->hi & 0x7FFFFFFF)*op2 + (temp >> 16);

  //overflow check
  if (ret.lo < (temp & 0xFFFF))
    ret.hi++;

  //maintain signed bit
  ret.hi = (ret.hi & 0x7FFFFFFF) | (op1->hi & 0x80000000);

  //copy to output
  retValue->lo = ret.lo;
  retValue->hi = ret.hi;
}

void addBigInt(bigInt_T *op1, bigInt_T *op2, bigInt_T *retValue)
{
  bigInt_T ret;                        //buffer incase intput == output
  if (op1->hi & 0x80000000) {
    if (op2->hi & 0x80000000) {        //neg + neg
      ret.lo = op1->lo + op2->lo;
      ret.hi = (op1->hi & 0x7FFFFFFF) + (op2->hi & 0x7FFFFFFF);
      if (ret.lo < op1->lo)
        ret.hi++;
      ret.hi |= 0x80000000;
    } else {                           //neg + pos
      if (absGreaterThan(op1, op2)) {
        ret.lo = op1->lo - op2->lo;
        ret.hi = (op1->hi & 0x7FFFFFFF) - (op2->hi & 0x7FFFFFFF);
        if (ret.lo > op1->lo)
          ret.hi--;
        ret.hi |= 0x80000000;
      } else {
        ret.lo = op2->lo - op1->lo;
        ret.hi = (op2->hi & 0x7FFFFFFF) - (op1->hi & 0x7FFFFFFF);
        if (ret.lo > op2->lo)
          ret.hi--;
        ret.hi &= 0x7FFFFFFF;
      }
    }
  } else {
    if (op2->hi & 0x80000000) {        //pos + neg
      if (absGreaterThan(op1, op2)) {
        ret.lo = op1->lo - op2->lo;
        ret.hi = (op1->hi & 0x7FFFFFFF) - (op2->hi & 0x7FFFFFFF);
        if (ret.lo > op1->lo)
          ret.hi--;
        ret.hi &= 0x7FFFFFFF;
      } else {
        ret.lo = op2->lo - op1->lo;
        ret.hi = (op2->hi & 0x7FFFFFFF) - (op1->hi & 0x7FFFFFFF);
        if (ret.lo > op2->lo)
          ret.hi--;
        ret.hi |= 0x80000000;
      }
    } else {                           //pos + pos
      ret.lo = op1->lo + op2->lo;
      ret.hi = (op1->hi & 0x7FFFFFFF) + (op2->hi & 0x7FFFFFFF);
      if (ret.lo < op1->lo)
        ret.hi++;
      ret.hi &= 0x7FFFFFFF;
    }
  }

  //copy to output
  retValue->lo = ret.lo;
  retValue->hi = ret.hi;
}

void shiftLeftBigInt(bigInt_T *in, uint16_T shift, bigInt_T *out)
{
  uint16_T i;
  out->lo = in->lo;
  out->hi = in->hi;
  for (i = 0; i < shift; i++) {
    out->lo = (out->lo >> 1) | (out->hi & 1) << 31;
    out->hi = (out->hi & 0x7FFFFFFF) >> 1 | (out->hi & 0x80000000);
  }
}

uint16_T TableAxis_real32_T(const real32_T in, const real32_T * data, const
  uint32_T width, const uint16_T prev)
{
  real32_T left = data[0];
  real32_T right = data[width-1];
  real32_T q, range;
  uint32_T hi, lo, i;
  uint16_T index, frac;
  if (left < right) {
    /* Increases Left to right */
    if (in <= left) {
      index = 0;
      return index;
    } else if (in >= right) {
      index = (width - 1)<<9;
      return index;
    } else {
      /* Find interpolation point */
      i = (prev>>9);                  /* Use previous point as starting point */
      if (data[i] <= in) {
        /* Go higher */
        while (i<width-1 && data[i] < in) {
          i++;
        }

        hi = i;
        lo = hi-1;
      } else {
        /* Go lower */
        while (i > 0 && data[i] > in) {
          i--;
        }

        lo = i;
        hi = lo + 1;
      }
    }
  } else {
    /* Decreases Left to right */
    if (in <= right) {
      index = (width - 1)<<9;
      return index;
    } else if (in >= left) {
      index = 0;
      return index;
    } else {
      /* Find interpolation point */
      i = (prev>>9);                  /* Use previous point as starting point */
      if (data[i] >= in) {
        /* Go lower */
        while (i<width-1 && data[i] > in) {
          i++;
        }

        lo = i;
        hi = lo-1;
      } else {
        /* Go higher */
        while (i > 0 && data[i] < in) {
          i--;
        }

        hi = i;
        lo = hi + 1;
      }
    }
  }

  q = in - data[lo];
  range = data[hi] - data[lo];
  if (range == 0)                      /* Avoid divide by 0 */
    return (uint16_T)(hi<<9);

  /* get fractional part */
  frac = (real32_T)((q*512.0F+range/2)/range);
  if (lo < hi)
    index = (uint16_T)(lo<<9) + frac;
  else
    index = (uint16_T)(lo<<9) - frac;
  return index;
}

real32_T TableInterpolate1D_real32_T( const uint16_T idx, const real32_T * data,
  const uint16_T width)
{
  uint16_T pos = (uint16_T)(idx >> 9);
  uint16_T frac = (uint16_T)(idx & 0x1FF);
  real32_T lo;
  real32_T hi;
  real32_T result;
  real32_T range;
  if (pos >= width-1) {
    result = data[width-1];
  } else {
    {
      lo = data[pos];
      hi = data[pos+1];
    }

    range = hi - lo;
    result = lo + (real32_T)(((real32_T)(frac * range)) / 512.0f);
  }

  return (real32_T)result;
}

real32_T TableInterpolate2D_real32_T( const uint16_T row_idx, const uint16_T
  col_idx, const real32_T * data, const uint16_T row_sz, const uint16_T col_sz)
{
  uint16_T row_pos = (uint16_T)(row_idx >> 9);
  uint16_T col_pos = (uint16_T)(col_idx >> 9);
  uint16_T row_frac = (uint16_T)(row_idx & 0x1FF);
  uint16_T col_frac = (uint16_T) (col_idx & 0x1FF);
  real32_T result;
  real32_T r0c0 = 0;
  real32_T r0c1 = 0;
  real32_T r1c0 = 0;
  real32_T r1c1 = 0;
  if (row_pos >= row_sz-1) {
    row_pos = (uint16_T) (row_sz-1);
    row_frac = 0;
  }

  if (col_pos >= col_sz-1) {
    col_pos = (uint16_T) (col_sz-1);
    col_frac = 0;
  }

  r0c0 = data[row_pos + col_pos*row_sz];
  result = (real32_T)r0c0 * (512-row_frac)*(512-col_frac);
  if (row_frac > 0) {
    r1c0 = data[(row_pos+1) + col_pos*row_sz];
    result += (real32_T)r1c0 * (row_frac)*(512-col_frac);
  }

  if (col_frac > 0) {
    r0c1 = data[row_pos + (col_pos+1)*row_sz];
    result += (real32_T)r0c1 * (512-row_frac)*(col_frac);
  }

  if (col_frac > 0 && row_frac > 0) {
    r1c1 = data[(row_pos+1) + (col_pos+1)*row_sz];
    result += (real32_T)r1c1 * (row_frac)*(col_frac);
  }

  result /= (512.0f * 512.0f);
  return result;
}
