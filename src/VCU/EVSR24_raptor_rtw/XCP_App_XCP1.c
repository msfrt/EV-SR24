/*****************************************************************************
   XCP_App_XCP1.c
   Generated By:
   Raptor 2023a_2.0.15039 (7682)
   Matlab (R2022b) 9.13

   Copyright (c) 2023 New Eagle Products, Inc.
   All rights reserved.

   Code Generated at: Tue Oct 17 21:06:40 2023
 *****************************************************************************/

#include "EVSR24.h"
#include "EVSR24_private.h"
#include "data.h"

/* S-Function Block: <S3>/raptor_xcp_update */
uint32_T XCP1__XCP_TX_ID_RAM = 768U;
XcpCan_MsgObjId_t g_msgObjId_XCP1;

#define TIMESUB(A,B)                   ((A >= B) ? (A-B):(0xFFFFFFFF-B+1+A))
#if defined __cplusplus || defined _cplusplus

extern "C"
{
  extern void Xcp_CmdProcessor(void);

#endif

  extern void XcpCan_RxCallback(uint32_T, uint8_T, uint8_T*);
  extern void XcpApp_CanTransmit_XCP1( XcpCan_MsgObjId_t msgObjId, uint32_T
    msgId, uint8_T numBytes, Xcp_StatePtr8 pBytes );

#if defined __cplusplus || defined _cplusplus

}

#endif

void RxTrig_XCP_BC_XCP1(void)
{
  uint32_T id;
  uint8_T length;
  uint16_T age;
  uint8_T extended;
  uint8_T data[8];
  uint32_T id_temp;
  length = can_get_RxTrig_XCP_BC_XCP1(&age, &id, &extended, &data[0], 8);
  id_temp = 0x100;
  if (extended) {
    id_temp |= 0x80000000;
  }

  XcpCan_RxCallback(id_temp, length, &data[0]);
  Xcp_CmdProcessor();
}

void RxTrig_XCP_CMD_XCP1(void)
{
  uint32_T id;
  uint8_T length;
  uint16_T age;
  uint8_T extended;
  uint8_T data[8];
  uint32_T id_temp;
  length = can_get_RxTrig_XCP_CMD_XCP1(&age, &id, &extended, &data[0], 8);
  id_temp = 0x200;
  if (extended) {
    id_temp |= 0x80000000;
  }

  XcpCan_RxCallback(id_temp, length, &data[0]);
  Xcp_CmdProcessor();
}

void XcpApp_CanTransmit_XCP1( XcpCan_MsgObjId_t msgObjId, uint32_T msgId,
  uint8_T numBytes, Xcp_StatePtr8 pBytes )
{
  /* Tx_XCP_XCP1  ------      */
  uint32_T id = XCP1__XCP_TX_ID_RAM;   //msgId & 0x1fffffff;
  uint8_T length = numBytes;
  uint8_T extended = ((msgId & 0x80000000) > 0);
  uint8_T data[8];
  memcpy(&data[0], pBytes, numBytes);
  can_send_Tx_XCP_XCP1(id, extended, length, &data[0]);
  g_msgObjId_XCP1 = msgObjId;
  if (g_msgObjId_XCP1 != XCPCAN_INVALID_MSGOBJID) {
    XcpCan_TxCallback(g_msgObjId_XCP1);
  }

  g_msgObjId_XCP1 = msgObjId;
}

extern void can_init_rxIdRxTrig_XCP_CMD_XCP1(uint32_T, uint8_T);
extern void can_init_rxIdRxTrig_XCP_BC_XCP1(uint32_T, uint8_T);
void XCP1_XCP_CAN_PreStart(uint32_T bc_id, uint32_T rx_id, uint32_T tx_id)
{
  XCP1__XCP_TX_ID_RAM = tx_id;
  XCP_MSG_RX_ID = rx_id;               /* Rx Id Type is Standard */
  can_init_rxIdRxTrig_XCP_BC_XCP1(bc_id, 0);
  can_init_rxIdRxTrig_XCP_CMD_XCP1(rx_id, 0);
}

void Timed_Trigger_XCP(void)
{
  uint32_T startTicks = (uint32_T)raptor_ticks_us();
  static uint32_T lastErrorMessageTicks = 0;
  uint32_T idleTimeRemaining = AppMonitorPctIdleTime_Data();
  uint8_T daq_dropped = 0;
  uint32_T daq_start = startTicks;
  uint32_T daq_end = startTicks;

  {
    /* DAQ LIST Rate : 10 ms */
    {
      /* If remaining idle time is greater than the last runtime of this DAQ, execute it. */
      if (idleTimeRemaining > XCP_DAQ00_10ms_Pct_Usage_Data() ||
          (AppMonitorState_Data() == APPMON_PAUSE)) {
        Xcp_DoDaqForEvent(0);
        daq_end = (uint32_T)raptor_ticks_us();
        XCP_DAQ00_10ms_Pct_Usage_Data() = TIMESUB(daq_end, daq_start);
        idleTimeRemaining = (idleTimeRemaining > XCP_DAQ00_10ms_Pct_Usage_Data())
          ? (idleTimeRemaining - XCP_DAQ00_10ms_Pct_Usage_Data()) : 0;
      } else {
        /* Send error message */
        daq_dropped = 1;
        daq_end = (uint32_T)raptor_ticks_us();
        XCP_Error_Count_Data() = XCP_Error_Count_Data() + 1;
      }
    }
  }

  {
    /* DAQ LIST Rate : 100 ms */
    static uint32_T cnt_daq__100ms = 1;
    if (cnt_daq__100ms >= 10) {
      cnt_daq__100ms = 0;

      /* If remaining idle time is greater than the last runtime of this DAQ, execute it. */
      if (idleTimeRemaining > XCP_DAQ01_100ms_Pct_Usage_Data() ||
          (AppMonitorState_Data() == APPMON_PAUSE)) {
        daq_start = daq_end;           /* prior daq end */
        Xcp_DoDaqForEvent(1);
        daq_end = (uint32_T)raptor_ticks_us();
        XCP_DAQ01_100ms_Pct_Usage_Data() = TIMESUB(daq_end, daq_start);
        idleTimeRemaining = (idleTimeRemaining > XCP_DAQ01_100ms_Pct_Usage_Data())
          ? (idleTimeRemaining - XCP_DAQ01_100ms_Pct_Usage_Data()) : 0;
      } else {
        /* Send error message */
        daq_dropped = 1;
        daq_end = (uint32_T)raptor_ticks_us();
        XCP_Error_Count_Data() = XCP_Error_Count_Data() + 1;
      }
    }

    cnt_daq__100ms++;
  }

  Xcp_CmdProcessor();
  if (daq_dropped) {
    uint8_T data[2] = { 0xFD, 0x06 };
                              /* EV_DAQ_OVERLOAD 0x06 DAQ processor overload. */

    /* Send CAN message with error identifier
     * XCP lib does not have a method for us to send an adhoc error message
     * so send an error message straight to CAN of 0x10: error-cmd-busy
     */
    if (raptor_ticks() - lastErrorMessageTicks > 250) {
      uint32_T id_temp = XCP1__XCP_TX_ID_RAM;

      {
        extern void XcpApp_CanTransmit_XCP1( XcpCan_MsgObjId_t msgObjId,
          uint32_T msgId, uint8_T numBytes, Xcp_StatePtr8 pBytes );
        XcpApp_CanTransmit_XCP1(XCPCAN_INVALID_MSGOBJID, id_temp, 2,
          (Xcp_StatePtr8)data);
        lastErrorMessageTicks = raptor_ticks();
      }
    }
  }

  XCP_DAQ_TotalUsage_Data() = TIMESUB(daq_end, startTicks);
  if (XCP_LongestRun_Data() == 0 || XCP_DAQ_TotalUsage_Data() >
      XCP_LongestRun_Data() )
    XCP_LongestRun_Data() =XCP_DAQ_TotalUsage_Data();
}
